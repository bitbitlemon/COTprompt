DATALOADER:
  TRAIN_X:
    BATCH_SIZE: 256        # CIFAR100N建议更大batch，稳定对比/OT统计（显存不够就降到128）
  TEST:
    BATCH_SIZE: 512        # 测试可更大
  NUM_WORKERS: 8
  PIN_MEMORY: True

INPUT:
  SIZE: (224, 224)         # 必须保持CLIP输入尺度
  INTERPOLATION: "bicubic"
  PIXEL_MEAN: [0.48145466, 0.4578275, 0.40821073]
  PIXEL_STD:  [0.26862954, 0.26130258, 0.27577711]

  # CIFAR-100N：更推荐“保守增广”，避免RRC把主体裁掉（32x32很脆）
  # 如果你的框架支持下列transform名，优先用这一套
  TRANSFORMS:
    - "random_crop"         # 先在32x32尺度做random crop + padding（更符合CIFAR习惯）
    - "random_flip"
    - "resize"              # 再resize到224给CLIP
    - "normalize"

  # 如果你的代码不支持 random_crop/resize 这类名称，
  # 那就把 TRANSFORMS 改成下面备选（兼容性更强）：
  # TRANSFORMS: ["random_flip", "normalize"]
  #
  # 并在数据集/transform实现里确保：CIFAR图像先做(32,32)的轻增广，再bicubic resize到(224,224)

OPTIM:
  NAME: "sgd"
  LR: 0.005                # 比0.01更稳（噪声集常见：0.01抖动/早早best）
  MOMENTUM: 0.9
  WEIGHT_DECAY: 0.0
  MAX_EPOCH: 50             # CIFAR100N上先跑50看曲线；需要再加到100
  LR_SCHEDULER: "cosine"
  WARMUP_EPOCH: 1
  WARMUP_TYPE: "constant"
  WARMUP_CONS_LR: 1e-5

TRAIN:
  PRINT_FREQ: 20
  CHECKPOINT_FREQ: 10
  SEED: 1

  # 噪声集更建议保存best（如果框架支持）
  SAVE_BEST: True
  METRIC: "accuracy"

MODEL:
  BACKBONE:
    NAME: "RN50"            # CLIP RN50

TRAINER:
  NLPROMPT:
    PROMPT_STYLE: "coop"
    N_CTX: 16
    CTX_INIT: ""            # 空初始化，让其自学习
    CSC: False              # 共享上下文，更稳、更抗噪
    CLASS_TOKEN_POSITION: "end"
    PREC: "amp"             # 必开，batch大更省显存

    # 如果你的实现支持“只训prompt/冻结backbone”，强烈建议打开（噪声集更稳）
    # FREEZE_BACKBONE: True

# ============（可选项：如果你的代码里有OT/噪声相关开关）============
# DATASET:
#   USE_OT: True             # 如果你确实实现了OT对齐，再打开
#   NUM_SHOTS: -1
#
# LOSS:
#   LABEL_SMOOTHING: 0.1     # 若框架支持，噪声标注常用（没有就忽略）
# ====================================================================
